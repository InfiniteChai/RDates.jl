var documenterSearchIndex = {"docs":
[{"location":"months_and_years/#Months-and-Years","page":"Months and Years","title":"Months and Years","text":"","category":"section"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"Adding months to a date is a surprisingly complex operation and so we've created a dedicated page to go through the details. For example","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"What should happen if I add one month to the 31st January?\nShould adding one month to the 30th April maintain the end of month?","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"Years are less complex, but still suffer from the same edge case due to leap years and the 29th February. As such, we incorporate the same conventions.","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"To give us the level of flexibility, we need to introduce two conventions to support us.","category":"page"},{"location":"months_and_years/#Month-Increment-Convention","page":"Months and Years","title":"Month Increment Convention","text":"","category":"section"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"When we add a month to a date, we need to determine what we should do with the day. Most of the time we'll maintain the same day, but sometimes we may want to maintain the last day of the month, which is a common feature in financial contracts.","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"RDates.MonthIncrementPDOM\n\nRDates.MonthIncrementPDOMEOM","category":"page"},{"location":"months_and_years/#RDates.MonthIncrementPDOM","page":"Months and Years","title":"RDates.MonthIncrementPDOM","text":"MonthIncrementPDOM()\n\nWhen incrementing by months (or years) then preserve the day of month from originally requested. Uses the \"PDOM\" shorthand\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/#RDates.MonthIncrementPDOMEOM","page":"Months and Years","title":"RDates.MonthIncrementPDOMEOM","text":"MonthIncrementPDOMEOM()\nMonthIncrementPDOMEOM(calendars)\n\nWhen incrementing by months (or years) then preserve the day of month from originally requested, unless it's the last day of the month then maintain that. Uses the \"PDOMEOM\" short hand.\n\nTo preserve the last business day of the month, then you can pass calendars as well.\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/#Invalid-Day-Convention","page":"Months and Years","title":"Invalid Day Convention","text":"","category":"section"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"The next convention we need is what to do if our increment leaves us on an invalid day of the month.","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"RDates.InvalidDayLDOM\n\nRDates.InvalidDayFDONM\n\nRDates.InvalidDayNDONM","category":"page"},{"location":"months_and_years/#RDates.InvalidDayLDOM","page":"Months and Years","title":"RDates.InvalidDayLDOM","text":"InvalidDayLDOM()\n\nWhen the day calculated is invalid, move to the last day of the month. Will use the \"LDOM\" short hand.\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/#RDates.InvalidDayFDONM","page":"Months and Years","title":"RDates.InvalidDayFDONM","text":"InvalidDayFDONM()\n\nWhen the day calculated is invalid, move to the first day of the next month. Uses the \"FDONM\" short hand.\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/#RDates.InvalidDayNDONM","page":"Months and Years","title":"RDates.InvalidDayNDONM","text":"InvalidDayNDONM()\n\nWhen the day calculated is invalid, move to the nth day of the next month where n is the number of days past the last day of the month. Uses the \"NDONM\" short hand.\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"We now have all the conventions we need to handle month and year adjustments","category":"page"},{"location":"months_and_years/","page":"Months and Years","title":"Months and Years","text":"RDates.Month\n\nRDates.Year","category":"page"},{"location":"months_and_years/#RDates.Month","page":"Months and Years","title":"RDates.Month","text":"Month(months::Int64)\nMonth(months::Int64, idc::InvalidDayConvention, mic::MonthIncrementConvention)\n\nProvides us with the ability to move a specified number of months, with conventions to handle how we should increment and what to do if we fall on an invalid day.\n\nExamples\n\njulia> RDates.Month(1) + Date(2019,1,31)\n2019-02-28\njulia> rd\"1m\" + Date(2019,1,31)\n2019-02-28\njulia> RDates.Month(1, RDates.InvalidDayFDONM(), RDates.MonthIncrementPDOM()) + Date(2019,1,31)\n2019-03-01\njulia> rd\"1m[FDONM;PDOM]\" + Date(2019,1,31)\n2019-03-01\njulia> RDates.Month(1, RDates.InvalidDayNDONM(), RDates.MonthIncrementPDOM()) + Date(2019,1,31)\n2019-03-03\njulia> rd\"1m[NDONM;PDOM]\" + Date(2019,1,31)\n2019-03-03\njulia> RDates.Month(1, RDates.InvalidDayNDONM(), RDates.MonthIncrementPDOMEOM()) + Date(2019,1,31)\n2019-02-28\njulia> rd\"1m[NDONM;PDOMEOM]\" + Date(2019,1,31)\n2019-02-28\njulia> RDates.Month(-1, RDates.InvalidDayNDONM(), RDates.MonthIncrementPDOMEOM()) + Date(2019,2,28)\n2019-01-31\njulia> rd\"-1m[NDONM;PDOMEOM]\" + Date(2019,2,28)\n2019-01-31\n\n\n\n\n\n","category":"type"},{"location":"months_and_years/#RDates.Year","page":"Months and Years","title":"RDates.Year","text":"Year(years::Int64)\nYear(years::Int64, idc::InvalidDayConvention, mic::MonthIncrementConvention)\n\nProvides us with the ability to move a specified number of months, with conventions to handle how we should increment and what to do if we fall on an invalid day.\n\nnote: Note\nWhile these conventions are necessary, it's only around the handling of leap years and when we're on the last day of the February that it actually matters.\n\nExamples\n\njulia> RDates.Year(1) + Date(2019,2,28)\n2020-02-28\njulia> rd\"1y\" + Date(2019,2,28)\n2020-02-28\njulia> RDates.Year(1, RDates.InvalidDayFDONM(), RDates.MonthIncrementPDOMEOM()) + Date(2019,2,28)\n2020-02-29\njulia> rd\"1y[FDONM;PDOMEOM]\" + Date(2019,2,28)\n2020-02-29\njulia> RDates.Year(1, RDates.InvalidDayLDOM(), RDates.MonthIncrementPDOM()) + Date(2020,2,29)\n2021-02-28\njulia> rd\"1y[LDOM;PDOM]\" + Date(2020,2,29)\n2021-02-28\njulia> RDates.Year(1, RDates.InvalidDayFDONM(), RDates.MonthIncrementPDOM()) + Date(2020,2,29)\n2021-03-01\njulia> rd\"1y[FDONM;PDOM]\" + Date(2020,2,29)\n2021-03-01\n\n\n\n\n\n","category":"type"},{"location":"business_days/#Business-Days","page":"Business Days","title":"Business Days","text":"","category":"section"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"Up to now we have dealt with date operations that do not take into consideration one of the key features, holidays. Whether its working around weekends or the UK's bank holidays, operations involving holidays (or equivalently business days) is essential.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"As such the RDate package provides the construct to allow you to work with holiday calendars, without tying you to a specific implementation.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"note: Note\nRDates will never provide an explicit implementation of the calendar system, but do check out HolidayCalendars which will get released soon which builds rule-based calendar systems.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"Before we walk through how this is integrated into the RDate language, we'll look at how calendars are modelled.","category":"page"},{"location":"business_days/#Calendars","page":"Business Days","title":"Calendars","text":"","category":"section"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"A calendar defines whether a given day is a holiday. To implement a calendar you need to inherit from RDates.Calendar and define the following methods.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.is_holiday\nRDates.holidays","category":"page"},{"location":"business_days/#RDates.is_holiday","page":"Business Days","title":"RDates.is_holiday","text":"is_holiday(calendar::Calendar, date::Dates.Date)::Bool\n\nDetermine whether the date requested is a holiday for this calendar or not.\n\n\n\n\n\n","category":"function"},{"location":"business_days/#RDates.holidays","page":"Business Days","title":"RDates.holidays","text":"holidays(calendar::Calendar, from::Dates.Date, to::Dates.Date)::Set{Dates.Date}\n\nGet the set of all holidays in the calendar between two dates (inclusive)\n\n\n\n\n\n","category":"function"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"Calendars also come with a number of helpful wrapper methods","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.holidaycount\nRDates.bizdaycount","category":"page"},{"location":"business_days/#RDates.holidaycount","page":"Business Days","title":"RDates.holidaycount","text":"holidaycount(calendar::Calendar, from::Dates.Date, to::Dates.Date)::Int\n\nGet the number of holidays in the calendar between two dates (inclusive)\n\n\n\n\n\n","category":"function"},{"location":"business_days/#RDates.bizdaycount","page":"Business Days","title":"RDates.bizdaycount","text":"bizdaycount(calendar::Calendar, from::Dates.Date, to::Dates.Date)::Int\n\nGet the number of business days in the calendar between two dates (inclusive)\n\n\n\n\n\n","category":"function"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDate provides some primitive calendar implementations to get started with","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.NullCalendar\nRDates.WeekendCalendar\nRDates.JointCalendar\nRDates.CachedCalendar","category":"page"},{"location":"business_days/#RDates.NullCalendar","page":"Business Days","title":"RDates.NullCalendar","text":"NullCalendar()\n\nA holiday calendar for which there is never a holiday. sigh\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.WeekendCalendar","page":"Business Days","title":"RDates.WeekendCalendar","text":"WeekendCalendar()\n\nA calendar which will mark every Saturday and Sunday as a holiday\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.JointCalendar","page":"Business Days","title":"RDates.JointCalendar","text":"JointCalendar(calendars::Vector{Calendar}) <: Calendar\n\nA grouping of calendars, for which it is a holiday if it's marked as a holiday for any of the underlying calendars.\n\nBy default addition of calendars will generate a joint calendar for you.\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.CachedCalendar","page":"Business Days","title":"RDates.CachedCalendar","text":"CachedCalendar(cal::Calendar)\n\nCreating a wrapping calendar that will cache the holidays lazily as retrieved for a given year, rather than loading them in one go.\n\n\n\n\n\n","category":"type"},{"location":"business_days/#Calendar-Manager","page":"Business Days","title":"Calendar Manager","text":"","category":"section"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"To access calendars within the relative date library, we use a calendar manager. It provides the interface to access calendars based on their name, a string identifier.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"A calendar manager must inherit from RDates.CalendarManager and implement the following","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"calendar(::RDates.CalendarManager, ::Vector)","category":"page"},{"location":"business_days/#RDates.calendar-Tuple{RDates.CalendarManager, Vector{T} where T}","page":"Business Days","title":"RDates.calendar","text":"calendar(calendarmgr::CalendarManager, names::Vector)::Calendar\n\nGiven a set of calendar names, request the calendar manager to retrieve the associated calendar that supports the union of them.\n\n\n\n\n\n","category":"method"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates provides some primitive calendar manager implementations to get started with","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.NullCalendarManager\nRDates.SimpleCalendarManager","category":"page"},{"location":"business_days/#RDates.NullCalendarManager","page":"Business Days","title":"RDates.NullCalendarManager","text":"NullCalendarManager()\n\nThe most primitive calendar manager, that will return an error for any request to get a calendar. The default calendar manager that is available when applying rdates using the + operator, without an explicit calendar manager.\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.SimpleCalendarManager","page":"Business Days","title":"RDates.SimpleCalendarManager","text":"SimpleCalendarManager()\nSimpleCalendarManager(calendars::Dict{String, Calendar})\n\nA basic calendar manager which just holds a reference to each underlying calendar, by name, and will generate a joint calendar if multiple names are requested.\n\nTo set a calendar on this manager then use setcalendar!\n\njulia> mgr = SimpleCalendarManager()\njulia> setcalendar!(mgr, \"WEEKEND\", WeekendCalendar())\nWeekendCalendar()\n\nIf you want to set a cached wrapping of a calendar then use setcachedcalendar!\n\njulia> mgr = SimpleCalendarManager()\njulia> setcachedcalendar!(mgr, \"WEEKEND\", WeekendCalendar())\nCachedCalendar(WeekendCalendar())\n\nExamples\n\njulia> mgr = SimpleCalendarManager()\njulia> setcalendar!(mgr, \"WEEKEND\", WeekendCalendar())\njulia> is_holiday(calendar(mgr, [\"WEEKEND\"]), Date(2019,9,28))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"When you just add a Date and an RDate then we'll use the NullCalendarManager() by default. To pass a calendar manager to the rdate when it's been applied, use the apply function.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.apply","category":"page"},{"location":"business_days/#RDates.apply","page":"Business Days","title":"RDates.apply","text":"apply(rdate::RDate, date::Dates.Date, calendarmgr::CalendarManager)::Dates.Date\n\nThe application of an rdate to a specific date, given an explicit calendar manager.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(rd\"1b@WEEKEND\", Date(2021,7,9), cal_mgr)\n2021-07-12\n\n\n\n\n\napply(rdate::RDate, date::Dates.Date)::Dates.Date\n\nThe application of an rdate to a specific date, without an explicit calendar manager. This will use the NullCalendarManager().\n\n\n\n\n\napply(rounding::HolidayRoundingConvention, date::Dates.Date, calendar::Calendar)::Dates.Date\n\nApply the holiday rounding to a given date. There is no strict requirement that the resolved date will not be a holiday for the given date.\n\n\n\n\n\n","category":"function"},{"location":"business_days/#Calendar-Adjustments","page":"Business Days","title":"Calendar Adjustments","text":"","category":"section"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"Now that we have a way for checking whether a given day is a holiday and can use your calendar manager, let's introduce calendar adjustments.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"These allow us to apply a holiday calendar adjustment, after a base rdate has been applied. To support this we need to introduce the concept of Holiday Rounding.","category":"page"},{"location":"business_days/#Holiday-Rounding-Convention","page":"Business Days","title":"Holiday Rounding Convention","text":"","category":"section"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"The holiday rounding convention provides the details on what to do if we fall on a holiday.","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.HolidayRoundingNBD\nRDates.HolidayRoundingPBD\nRDates.HolidayRoundingNBDSM\nRDates.HolidayRoundingPBDSM\nRDates.HolidayRoundingNR\nRDates.HolidayRoundingNearest","category":"page"},{"location":"business_days/#RDates.HolidayRoundingNBD","page":"Business Days","title":"RDates.HolidayRoundingNBD","text":"HolidayRoundingNBD()\n\nMove to the next business day when a date falls on a holiday.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingNBD()), Date(2021,7,10), cal_mgr)\n2021-07-12\njulia> apply(rd\"0d@WEEKEND[NBD]\", Date(2021,7,10), cal_mgr)\n2021-07-12\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.HolidayRoundingPBD","page":"Business Days","title":"RDates.HolidayRoundingPBD","text":"HolidayRoundingPBD()\n\nMove to the previous business day when a date falls on a holiday.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingPBD()), Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0d@WEEKEND[PBD]\", Date(2021,7,10), cal_mgr)\n2021-07-09\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.HolidayRoundingNBDSM","page":"Business Days","title":"RDates.HolidayRoundingNBDSM","text":"HolidayRoundingNBDSM()\n\nMove to the next business day when a date falls on a holiday, unless the adjusted date would be in the next month, then go the previous business date instead.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingNBDSM()), Date(2021,7,10), cal_mgr)\n2021-07-12\njulia> apply(rd\"0d@WEEKEND[NBDSM]\", Date(2021,7,10), cal_mgr)\n2021-07-12\njulia> apply(rd\"0d@WEEKEND[NBDSM]\", Date(2021,7,31), cal_mgr)\n2021-07-30\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.HolidayRoundingPBDSM","page":"Business Days","title":"RDates.HolidayRoundingPBDSM","text":"HolidayRoundingPBDSM()\n\nMove to the previous business day when a date falls on a holiday, unless the adjusted date would be in the previous month, then go the next business date instead.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingPBDSM()), Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0d@WEEKEND[PBDSM]\", Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0d@WEEKEND[NBDSM]\", Date(2021,8,1), cal_mgr)\n2021-08-02\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.HolidayRoundingNR","page":"Business Days","title":"RDates.HolidayRoundingNR","text":"HolidayRoundingNR()\n\nNo rounding, so just give back the same date even though it's a holiday. Uses \"NR\" for short hand.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingNR()), Date(2021,7,10), cal_mgr)\n2021-07-10\njulia> apply(rd\"0d@WEEKEND[NR]\", Date(2021,7,10), cal_mgr)\n2021-07-10\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.HolidayRoundingNearest","page":"Business Days","title":"RDates.HolidayRoundingNearest","text":"HolidayRoundingNearest()\n\nMove to the nearest business day, with the next one taking precedence in a tie. This is commonly used for U.S. calendars which will adjust Sat to Fri and Sun to Mon for their fixed date holidays.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.CalendarAdj(\"WEEKEND\", rd\"0d\", RDates.HolidayRoundingNearest()), Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0d@WEEKEND[NEAR]\", Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0d@WEEKEND[NEAR]\", Date(2021,7,11), cal_mgr)\n2021-07-12\n\n\n\n\n\n","category":"type"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"Now we have everything we need to define calendar adjustments and business days","category":"page"},{"location":"business_days/","page":"Business Days","title":"Business Days","text":"RDates.CalendarAdj\nRDates.BizDays","category":"page"},{"location":"business_days/#RDates.CalendarAdj","page":"Business Days","title":"RDates.CalendarAdj","text":"CalendarAdj(calendars, rdate::RDate, rounding::HolidayRoundingConvention)\n\nApply a calendar adjustment to an underlying rdate, applying an appropriate convention if our final date falls on a holiday.\n\nThe calendars can only use alphanumeric characters, plus /, - and .\n\nIn the string-form, you can apply a calendar adjustment using the @ character and provide | separated calendar names to apply it on. The convention is finally provided in square brackets using its string-form name.\n\nExamples\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(rd\"1d\", Date(2019,9,27), cal_mgr)\n2019-09-28\njulia> apply(rd\"1d@WEEKEND[NBD]\", Date(2019,9,27), cal_mgr)\n2019-09-30\njulia> apply(rd\"2m - 1d\", Date(2019,7,23), cal_mgr)\n2019-09-22\njulia> apply(rd\"(2m - 1d)@WEEKEND[PBD]\", Date(2019,7,23), cal_mgr)\n2019-09-20\n\n\n\n\n\n","category":"type"},{"location":"business_days/#RDates.BizDays","page":"Business Days","title":"RDates.BizDays","text":"BizDays(days::Int64, calendars)\nBizDays(days::BizDayZero)\n\nIt can be handy to work in business days at times, rather than calendar days. This allows us to move forwards or backwards n days.\n\njulia> cal_mgr = SimpleCalendarManager()\njulia> setcalendar!(cal_mgr, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.BizDays(1, \"WEEKEND\"), Date(2021,7,9), cal_mgr)\n2021-07-12\njulia> apply(rd\"1b@WEEKEND\", Date(2021,7,9), cal_mgr)\n2021-07-12\njulia> apply(RDates.BizDays(-10, \"WEEKEND\"), Date(2021,7,9), cal_mgr)\n2021-06-25\n\nIf the date falls on a holiday, then it is first moved forward (or backwards) to a valid business day.\n\njulia> apply(RDates.BizDays(1, \"WEEKEND\"), Date(2021,7,10), cal_mgr)\n2021-07-13\n\nFor zero business days, we could either want to move forwards or backwards. As such we provide BizDayZero which can be used to provide each. By default, 0b will move forward\n\njulia> apply(RDates.BizDays(RDates.BizDayZero(:next), \"WEEKEND\"), Date(2021,7,10), cal_mgr)\n2021-07-12\njulia> apply(RDates.BizDays(RDates.BizDayZero(:prev), \"WEEKEND\"), Date(2021,7,10), cal_mgr)\n2021-07-09\njulia> apply(rd\"0b@WEEKEND\", Date(2021,7,10), cal_mgr)\n2021-07-12\njulia> apply(rd\"-0b@WEEKEND\", Date(2021,7,10), cal_mgr)\n2021-07-09\n\n\n\n\n\n","category":"type"},{"location":"primitives/#Primitives","page":"Primitives","title":"Primitives","text":"","category":"section"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"RDates is designed to allow complex date operations to be completed using basic primitive types. Each of these primitive types and operations are explained in more detail in subsequent sections.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"We now go through each of the primitive types, from which we can combine together using compounding operations. Also take note of the examples and the associated short-hand that we can use to define them with the rd\"\" macro.","category":"page"},{"location":"primitives/","page":"Primitives","title":"Primitives","text":"RDates.Day\n\nRDates.Week\n\nRDates.FDOM\n\nRDates.LDOM\n\nRDates.Easter\n\nRDates.DayMonth\n\nRDates.Date\n\nRDates.NthWeekdays\n\nRDates.NthLastWeekdays\n\nRDates.Weekdays","category":"page"},{"location":"primitives/#RDates.Day","page":"Primitives","title":"RDates.Day","text":"Day(days::Int64)\n\nProvides us with the ability to add or subtract days from a date. This is equivalent to the Dates.Day struct.\n\nExamples\n\njulia> RDates.Day(3) + Date(2019,1,1)\n2019-01-04\njulia> rd\"3d\" + Date(2019,1,1)\n2019-01-04\njulia> RDates.Day(-2) + Date(2019,1,1)\n2018-12-30\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.Week","page":"Primitives","title":"RDates.Week","text":"Week(weeks::Int64)\n\nProvides us with the ability to add or subtract weeks from a date. This is equivalent to the Dates.Week struct.\n\nExamples\n\njulia> RDates.Week(3) + Date(2019,1,1)\n2019-01-22\njulia> rd\"3w\" + Date(2019,1,1)\n2019-01-22\njulia> RDates.Week(-2) + Date(2019,1,1)\n2018-12-18\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.FDOM","page":"Primitives","title":"RDates.FDOM","text":"FDOM()\nFDOM(calendars)\n\nCalculate the first day of the month. Optionally can also take calendar names to determine the first business day of the month.\n\nExamples\n\njulia> RDates.FDOM() + Date(2019,1,13)\n2019-01-01\njulia> rd\"FDOM\" + Date(2019,1,13)\n2019-01-01\n\njulia> cals = SimpleCalendarManager()\njulia> setcalendar!(cals, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.FDOM(\"WEEKEND\"), Date(2017,1,13), cals)\n2017-01-02\njulia> apply(rd\"FDOM@WEEKEND\", Date(2017,1,13), cals)\n2017-01-02\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.LDOM","page":"Primitives","title":"RDates.LDOM","text":"LDOM()\nLDOM(calendars)\n\nCalculate the last day of the month. Optionally can also take calendar names to determine the last business day of the month.\n\nExamples\n\njulia> RDates.LDOM() + Date(2019,1,13)\n2019-01-31\njulia> rd\"LDOM\" + Date(2019,1,13)\n2019-01-31\njulia> cals = SimpleCalendarManager()\njulia> setcalendar!(cals, \"WEEKEND\", WeekendCalendar())\njulia> apply(RDates.LDOM(\"WEEKEND\"), Date(2021,1,13), cals)\n2021-01-29\njulia> apply(rd\"LDOM@WEEKEND\", Date(2021,1,13), cals)\n2021-01-29\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.Easter","page":"Primitives","title":"RDates.Easter","text":"Easter(yearδ::Int64)\n\nA date that is well known from hunting eggs and pictures of bunnies, it's a rather tricky calculation to perform. We provide a simple method to allow you to get the Easter for the given year (plus some delta).\n\nnote: Note\n0E will get the Easter of the current year, so it could be before or after the date you've provided.\n\nExamples\n\njulia> RDates.Easter(0) + Date(2019,1,1)\n2019-04-21\njulia> rd\"0E\" + Date(2019,1,1)\n2019-04-21\njulia> RDates.Easter(0) + Date(2019,8,1)\n2019-04-21\njulia> RDates.Easter(10) + Date(2019,8,1)\n2029-04-01\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.DayMonth","page":"Primitives","title":"RDates.DayMonth","text":"DayMonth(day::Int64, month::Int64)\nDayMonth(day::Int64, month::Symbol)\n\nProvides us with the ability to move to a specific day and month in the provided year.\n\nnote: Note\n1MAR will get the 1st of March of the current year, so it could be before or after the date you've provided.\n\nExamples\n\njulia> RDates.DayMonth(23, 10) + Date(2019,1,1)\n2019-10-23\njulia> RDates.DayMonth(23, :OCT) + Date(2019,1,1)\n2019-10-23\njulia> rd\"23OCT\" + Date(2019,1,1)\n2019-10-23\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.Date","page":"Primitives","title":"RDates.Date","text":"Date(date::Dates.Date)\nDate(year::Int64, month::Int64, day::Int64)\n\nProvides us with the ability to move to a specific date, irrespective of the date passed in. This is primarily used when you want to provide a pivot point for ranges which doesn't relate to the start or end.\n\nExamples\n\njulia> RDates.Date(Dates.Date(2017,10,23)) + Date(2019,1,1)\n2017-10-23\njulia> RDates.Date(2017,10,23) + Date(2019,1,1)\n2017-10-23\njulia> rd\"23OCT2017\" + Date(2019,1,1)\n2017-10-23\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.NthWeekdays","page":"Primitives","title":"RDates.NthWeekdays","text":"NthWeekdays(dayofweek::Int64, period::Int64)\nNthWeekdays(dayofweek::Symbol, period::Int64)\n\nMove to the nth weekday in the given month and year. This is commonly used for holiday calendars, such as Thanksgiving which in the U.S. falls on the 4th Thursday in November.\n\nnote: Note\nIt's possible that a given period (such as the 5th weekday) may exist for only a subsection of dates. While it's a valid RDate it may not produce valid results when applied (and will throw an exception)\n\nExamples\n\njulia> RDates.NthWeekdays(:MON, 2) + Date(2019,1,1)\n2019-01-14\njulia> RDates.NthWeekdays(1, 2) + Date(2019,1,1)\n2019-01-14\njulia> rd\"2nd MON\" + Date(2019,1,1)\n2019-01-14\njulia> RDates.NthWeekdays(:MON, 5) + Date(2019,1,1)\nERROR: ArgumentError: Day: 35 out of range (1:31)\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.NthLastWeekdays","page":"Primitives","title":"RDates.NthLastWeekdays","text":"NthLastWeekdays(dayofweek::Int64, period::Int64)\nNthLastWeekdays(dayofweek::Symbol, period::Int64)\n\nMove to the nth last weekday in the given month and year. This is commonly used for holiday calendars, such as the Spring Bank Holiday in the UK, which is the last Monday in May.\n\nnote: Note\nIt's possible that a given period (such as the 5th Last weekday) may exist for only a subsection of dates. While it's a valid RDate it may not produce valid results when applied (and will throw an exception)\n\nExamples\n\njulia> RDates.NthLastWeekdays(:MON, 2) + Date(2019,1,1)\n2019-01-21\njulia> RDates.NthLastWeekdays(1, 2) + Date(2019,1,1)\n2019-01-21\njulia> rd\"2nd Last MON\" + Date(2019,1,1)\n2019-01-21\njulia> RDates.NthLastWeekdays(:MON, 5) + Date(2019,1,1)\nERROR: ArgumentError: Day: 0 out of range (1:31)\n\n\n\n\n\n","category":"type"},{"location":"primitives/#RDates.Weekdays","page":"Primitives","title":"RDates.Weekdays","text":"Weekdays(dayofweek::Int64, count::Int64, inclusive::Bool = false)\nWeekdays(dayofweek::Symbol, count::Int64, inclusive::Bool = false)\n\nProvides a mechanism to ask for the next Saturday or the last Tuesday. The count specifies what we're looking for. Weekdays(:MON, 1) will ask for the next Monday, exclusive of the date started from. You can make it inclusive by passing the inclusive parameter with Weekdays(:MON, 1, true).\n\nnote: Note\nA count of 0 is not supported as it doesn't specify what you're actually looking for!\n\nIncrementing the count will then be additional weeks (forward or backwards) from the single count point.\n\nExamples\n\njulia> RDates.Weekdays(:WED, 1) + Date(2019,9,24) # Tuesday\n2019-09-25\njulia> RDates.Weekdays(3, 1) + Date(2019,9,24)\n2019-09-25\njulia> rd\"1WED\" + Date(2019,9,24)\n2019-09-25\njulia> RDates.Weekdays(:WED, 1) + Date(2019,9,25)\n2019-10-02\njulia> RDates.Weekdays(:WED, 1, true) + Date(2019,9,25)\n2019-09-25\njulia> rd\"1WED!\" + Date(2019,9,25)\n2019-09-25\njulia> RDates.Weekdays(:WED, -1) + Date(2019,9,24)\n2019-09-18\n\n\n\n\n\n","category":"type"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A relative date library for Julia","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a project that builds around the Dates module to allow complex date arithmetic.  ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The aim is to provide a standard toolset to allow you to answer questions such as when is the next Easter or what are the next 4 IMM dates from today?","category":"page"},{"location":"#Package-Features","page":"Introduction","title":"Package Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A generic, extendable algebra for date operations with a rich set of primitives.\nA composable design to allow complex combinations of relative date operations.\nAn extendable parsing library to provide a language to describe relative dates.\nAn interface for integrating holiday calendar systems.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"RDates can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add RDates","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At this point you can now start using RDates in your current Julia session using the following command","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using RDates","category":"page"},{"location":"#Answering-Those-Questions","page":"Introduction","title":"Answering Those Questions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"So while the documentation will provide the details, let's see a quick start on how it works","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"When is the next Easter?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> rd\"Next(0E,1E)\" + Date(2021,7,12)\n2022-04-17","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"What are the next 4 IMM dates?","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> d = Date(2021,7,12)\njulia> collect(Iterators.take(range(d, rd\"1MAR+3m+3rd WED\"), 4))\n4-element Vector{Date}:\n 2021-09-15\n 2021-12-15\n 2022-03-16\n 2022-06-15","category":"page"},{"location":"combinations/#Combinations","page":"Combinations","title":"Combinations","text":"","category":"section"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"One of the key features of RDates is to allow us to combine primitive operations to provide a generalised method to describe date adjustments.","category":"page"},{"location":"combinations/#Negation","page":"Combinations","title":"Negation","text":"","category":"section"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"All our primitive operations provide a negative operation, which is achieved by applying the - operator to the RDate.","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> Date(2019,1,1) - RDates.Day(1)\n2018-12-31\njulia> -RDates.Week(3) + Date(2019,1,1)\n2018-12-11","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"note: Note\nWhile all our RDates support negation, they may not have an effect and will just return itself.julia> -rd\"1st WED\" == rd\"1st WED\"\ntrue","category":"page"},{"location":"combinations/#Addition","page":"Combinations","title":"Addition","text":"","category":"section"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"All RDates can be combined together via addition. The components are applied from left to right.","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> rd\"1d + 1y\" + Date(2019,1,1)\n2020-01-02\njulia> rd\"1MAR + 3rd WED\" + Date(2019,1,1)\n2019-03-20","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"note: Note\nWhere possible, addition operations may be optimised to reduce down to simpler state. This will always be done in a way in which we maintain the expected behaviour.julia> rd\"1d + 1d\" == rd\"2d\"\ntrue","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"warning: Warning\nThe alegbra of month addition is not always straight forward. Make sure you're clear on exactly what you want to achieve.julia> rd\"2m\" + Date(2019,1,31)\n2019-03-31\njulia> rd\"1m + 1m\" + Date(2019,1,31)\n2019-03-28","category":"page"},{"location":"combinations/#Multiplication-and-Repeats","page":"Combinations","title":"Multiplication and Repeats","text":"","category":"section"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"Every RDate supports multiplication and this will usually multiply it's underlying count. For most primitives this is completely understandable due to the inherent link between addition and multiplication.","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> RDates.Day(2) * 5\n10d\njulia> RDates.Week(2) * -5\n-10w","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"For RDates which do not have a natural count then the multiplication will just return itself","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> 10 * RDates.NthWeekdays(:MON, 1)\n1st MON","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"However when we come to handling months (and by extension years, though in rarer cases) we need to be more careful. We set a convention that multiplication is equivalent to multiplication of the internal count and so we won't get the same result as adding it n times.","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> 2 * RDates.Month(1)\n2m[LDOM;PDOM]\njulia> rd\"2 * 1m\"\n2m[LDOM;PDOM]\njulia> 2 * RDates.Month(1) + Date(2019,1,31)\n2019-03-31\njulia> RDates.Month(1) + RDates.Month(1) + Date(2019,1,31)\n2019-03-28","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"It may be though that you want that handling and so we introduce the Repeat operator to support that. This operator will repeat the application of the internalised rdate, rather than passing the multiplier through.","category":"page"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"julia> 2 * RDates.Repeat(RDates.Month(1))\n2*Repeat(1m[PDOM;LDOM])\njulia> 2 * RDates.Repeat(RDates.Month(1)) + Date(2019,1,31)\n2019-03-28\njulia> rd\"2*Repeat(1m)\" + Date(2019,1,31)\n2019-03-28","category":"page"},{"location":"combinations/#Other-Operators","page":"Combinations","title":"Other Operators","text":"","category":"section"},{"location":"combinations/","page":"Combinations","title":"Combinations","text":"RDates.Next\n\nRDates.Previous","category":"page"},{"location":"combinations/#RDates.Next","page":"Combinations","title":"RDates.Next","text":"Next(parts, inclusive::Bool = false)\n\nNext is a mechanism through which we can find the next closest date in the future, given a list of rdates to apply. We can choose whether today is also deemed a valid date.\n\nThis is commonly used in conjunction with rdates which don't necessarily always give a date in the future, such as asking for the next Easter from today.\n\nExamples\n\njulia> RDates.Next([RDates.Easter(0), RDates.Easter(1)]) + Date(2019,1,1)\n2019-04-21\njulia> rd\"Next(0E,1E)\" + Date(2019,1,1)\n2019-04-21\njulia> RDates.Next([RDates.Easter(0), RDates.Easter(1)]) + Date(2019,4,21)\n2020-04-12\njulia> RDates.Next([RDates.Easter(0), RDates.Easter(1)], true) + Date(2019,4,21)\n2019-04-21\njulia> rd\"Next!(0E,1E)\" + Date(2019,4,21)\n2019-04-21\n\nnote: Note\nThe negation of Next will actually produce a Previous.julia> -rd\"Next(1d,2d)\"\nPrevious(-1d, -2d)\njulia> -3 * rd\"Next(1d,2d)\"\nPrevious(-3d, -6d)\n\nwarning: Warning\nWhile Next is a powerful operator, it does require application of every rdate every time, so can be expensive.When combining with ranges, it can often be useful to use an appropriate pivot point to start from instead.\n\n\n\n\n\n","category":"type"},{"location":"combinations/#RDates.Previous","page":"Combinations","title":"RDates.Previous","text":"Previous(parts, inclusive::Bool = false)\n\nPrevious is a mechanism through which we can find the next closest date in the past, given a list of rdates to apply. We can choose whether today is also deemed a valid date.\n\nThis is commonly used in conjunction with rdates which don't necessarily always give a date in the future, such as asking for the previous Easter from today.\n\nExamples\n\njulia> RDates.Previous([RDates.Easter(0), RDates.Easter(-1)]) + Date(2019,12,31)\n2019-04-21\njulia> rd\"Previous(0E,-1E)\" + Date(2019,12,31)\n2019-04-21\njulia> RDates.Previous([RDates.Easter(0), RDates.Easter(-1)]) + Date(2019,4,21)\n2018-04-01\njulia> RDates.Previous([RDates.Easter(0), RDates.Easter(-1)], true) + Date(2019,4,21)\n2019-04-21\njulia> rd\"Previous!(0E,-1E)\" + Date(2019,4,21)\n2019-04-21\n\nnote: Note\nThe negation of Previous will actually produce a Next.julia> -rd\"Previous(-1d,-2d)\"\nNext(1d, 2d)\njulia> -3 * rd\"Previous(-1d,-2d)\"\nNext(3d, 6d)\n\nwarning: Warning\nWhile Previous is a powerful operator, it does require application of every rdate every time, so can be expensive.When combining with ranges, it can often be useful to use an appropriate pivot point to start from instead.\n\n\n\n\n\n","category":"type"},{"location":"ranges/#Ranges","page":"Ranges","title":"Ranges","text":"","category":"section"},{"location":"ranges/","page":"Ranges","title":"Ranges","text":"RDates.RDateRange","category":"page"},{"location":"ranges/#RDates.RDateRange","page":"Ranges","title":"RDates.RDateRange","text":"range(from::Date, rdate::RDate; inc_from=true, cal_mgr=nothing)\nrange(from::Date, to::Date, rdate::RDate; inc_from=true, inc_to=true, cal_mgr=nothing)\n\nThe range provides a mechanism for iterating over a range of dates given a period. This can provide a mechanism for getting an infinite range (from a given date) or appropriately clipped.\n\njulia> collect(Iterators.take(range(Date(2017,1,25), rd\"1d\"), 3))\n3-element Vector{Date}:\n 2017-01-25\n 2017-01-26\n 2017-01-27\njulia> collect(Iterators.take(range(Date(2017,1,25), rd\"1d\"; inc_from=false), 3))\n3-element Vector{Date}:\n 2017-01-26\n 2017-01-27\n 2017-01-28\njulia> collect(range(Date(2019,4,17), Date(2019,4,22), rd\"2d\"))\n3-element Vector{Date}:\n 2019-04-17\n 2019-04-19\n 2019-04-21\n\nUnder the hoods, the range will multiply the period. Since non-periodic RDates will always give back self when you multiply it allows us to set a reference point.\n\njulia> rd\"1JAN2001+3m+3rd WED\"\n1JAN2001+3m[LDOM;PDOM]+3rd WED\njulia> 3*rd\"1JAN2001+3m+3rd WED\"\n1JAN2001+9m[LDOM;PDOM]+3rd WED\n\nThis provides the basic building blocks to come up with more complex functionality. For example to get the next four IMM dates\n\njulia> d = Date(2017,1,1)\njulia> collect(Iterators.take(range(d, rd\"1MAR+3m+3rd WED\"), 4))\n4-element Vector{Date}:\n 2017-03-15\n 2017-06-21\n 2017-09-20\n 2017-12-20\n\n\n\n\n\n","category":"type"}]
}
